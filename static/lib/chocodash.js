// Generated by CoffeeScript 1.12.6
(function() {
  var Observer, Publisher, Signal, _, _module,
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _module = typeof window !== "undefined" && window !== null ? window : module;

  _module[_module.exports != null ? "exports" : "Chocodash"] = _ = {};

  _.type = function(o) {
    return Object.prototype.toString.apply(o);
  };

  _.Type = {
    Object: '[object Object]',
    Array: '[object Array]',
    Boolean: '[object Boolean]',
    Number: '[object Number]',
    Date: '[object Date]',
    Function: '[object Function]',
    Math: '[object Math]',
    String: '[object String]',
    Undefined: '[object Undefined]',
    Null: '[object Null]'
  };

  _.isObject = function(o) {
    if (o == null) {
      return false;
    }
    switch (typeof o) {
      case 'object':
      case 'function':
        return true;
      default:
        return false;
    }
  };

  _.isBasicObject = function(o) {
    if (o == null) {
      return false;
    }
    return o.constructor === {}.constructor;
  };

  _.prototype = function(options, more) {
    var constructor, ctor, fn, k, name, prototype, v, value;
    if (more != null) {
      if (options != null) {
        for (k in more) {
          v = more[k];
          options[k] = v;
        }
      } else {
        options = more;
      }
      more = null;
    }
    prototype = (function() {
      var flatten;
      flatten = function() {
        var args;
        args = [];
        if (arguments[0] != null) {
          Array.prototype.push.apply(args, arguments);
        }
        return args;
      };
      return {
        use: function() {
          var len, len1, m, o, oo, p, ref;
          ref = flatten.apply(null, arguments);
          for (m = 0, len = ref.length; m < len; m++) {
            o = ref[m];
            switch (_.type(o)) {
              case _.Type.Function:
                o.call(this.prototype);
                break;
              case _.Type.Array:
                for (p = 0, len1 = o.length; p < len1; p++) {
                  oo = o[p];
                  for (k in oo) {
                    if (!hasProp.call(oo, k)) continue;
                    v = oo[k];
                    this.prototype[k] = v;
                  }
                }
                break;
              default:
                for (k in o) {
                  if (!hasProp.call(o, k)) continue;
                  v = o[k];
                  this.prototype[k] = v;
                }
            }
          }
          return this;
        },
        adopt: function() {
          var len, m, o, ref, ref1;
          ref = flatten.apply(null, arguments);
          for (m = 0, len = ref.length; m < len; m++) {
            o = ref[m];
            for (k in o) {
              if (!hasProp.call(o, k)) continue;
              v = o[k];
              this[k] = v;
            }
            ref1 = o.prototype;
            for (k in ref1) {
              if (!hasProp.call(ref1, k)) continue;
              v = ref1[k];
              this.prototype[k] = v;
            }
          }
          return this;
        },
        inherit: function(parent) {
          var child, ctor;
          child = this;
          if (parent != null) {
            if (parent instanceof _.Prototyper) {
              child.__prototyper__ = parent.prototyper;
              parent = parent.prototyper();
            }
            for (k in parent) {
              if (!hasProp.call(parent, k)) continue;
              v = parent[k];
              child[k] = v;
            }
            ctor = function() {
              this.constructor = child;
            };
            ctor.prototype = parent.prototype;
            child.prototype = new ctor();
            child.__super__ = parent.prototype;
          }
          return this;
        }
      };
    })();
    constructor = (options != null ? options.hasOwnProperty('constructor') : void 0) ? options.constructor : null;
    ctor = (function() {
      switch (false) {
        case !((constructor != null) && ((options != null ? options.inherit : void 0) != null)):
          return function() {
            Array.prototype.unshift.call(arguments, this);
            _["super"].apply(_, arguments);
            Array.prototype.shift.call(arguments);
            constructor.apply(this, arguments);
          };
        case constructor == null:
          return function() {
            constructor.apply(this, arguments);
          };
        case (options != null ? options.inherit : void 0) == null:
          return function() {
            Array.prototype.unshift.call(arguments, this);
            _["super"].apply(_, arguments);
          };
        default:
          return function() {};
      }
    })();
    if (options != null) {
      for (name in options) {
        value = options[name];
        if (name === 'adopt' || name === 'inherit' || name === 'use') {
          prototype[name].call(ctor, value);
        } else {
          if (name !== 'constructor') {
            ctor.prototype[name] = value;
          }
        }
      }
    }
    for (name in prototype) {
      if (!hasProp.call(prototype, name)) continue;
      fn = prototype[name];
      if (ctor[name] == null) {
        ctor[name] = fn;
      }
    }
    return ctor;
  };

  _["super"] = function() {
    var _func, _name, constructor, func, k, ref, self, super_func, v;
    super_func = null;
    func = arguments[0], self = arguments[1];
    if (typeof func !== 'function') {
      self = func;
      func = null;
    }
    _func = func != null ? func : arguments.callee.caller;
    _name = null;
    constructor = self.constructor;
    if (constructor === _func.caller) {
      super_func = constructor.__super__.constructor;
    } else {
      while (constructor && (super_func == null)) {
        ref = constructor.prototype;
        for (k in ref) {
          if (!hasProp.call(ref, k)) continue;
          v = ref[k];
          if (_func === v) {
            _name = k;
            break;
          }
        }
        if (_name != null) {
          super_func = constructor.__super__[_name];
        }
        if (super_func == null) {
          constructor = constructor.__super__ != null ? constructor.__super__.constructor : null;
        }
      }
    }
    if (super_func) {
      return super_func.apply(self, Array.prototype.slice.call(arguments, func != null ? 2 : 1));
    }
  };

  _.Prototyper = _.prototype({
    constructor: function(prototyper1) {
      this.prototyper = prototyper1;
    }
  });

  _.prototyper = function(prototyper) {
    return new _.Prototyper(prototyper);
  };

  _.stringify = function() {
    var array_as_object, concat, doit, newline, object, options, ref, tab, write;
    if (arguments.length === 0) {
      return void 0;
    }
    object = arguments[0];
    options = (ref = arguments[1]) != null ? ref : {};
    if (options.prettify === true) {
      tab = '    ';
      newline = '\n';
    } else {
      tab = newline = '';
    }
    array_as_object = false;
    switch (options.mode) {
      case 'json':
        return JSON.stringify(object, null, tab);
      case 'full':
        array_as_object = true;
        break;
      case 'js':
    }
    write = typeof options.write === 'function' ? options.write : function(str) {
      return str;
    };
    concat = function(w1, w2, w3) {
      if ((w1 != null) && (w2 != null) && (w3 != null)) {
        return w1 + w2 + w3;
      } else {
        return null;
      }
    };
    doit = function(o, level, index) {
      var chunk, i, indent, k, ni, nit, sep, type, v;
      if (level == null) {
        level = 0;
      }
      indent = tab === '' ? '' : ((function() {
        var m, ref1, results;
        results = [];
        for (m = 0, ref1 = level; 0 <= ref1 ? m < ref1 : m > ref1; 0 <= ref1 ? m++ : m--) {
          results.push(tab);
        }
        return results;
      })()).join('');
      ni = newline + indent;
      nit = ni + tab;
      type = Object.prototype.toString.apply(o);
      sep = index > 0 ? ',' + nit : '';
      switch (type) {
        case '[object Object]':
          if (o.constructor !== {}.constructor && (o.stringify != null) && typeof o.stringify === 'function') {
            return write(sep + o.stringify());
          } else {
            if (o.constructor !== {}.constructor && options.strict) {
              throw "_.stringify in strict mode can only accept pure objects";
            } else {
              i = 0;
              return concat(write(sep + ("" + (options.variable && level === 0 ? 'var ' : '{') + nit)), "" + (((function() {
                var ref1, results;
                results = [];
                for (k in o) {
                  v = o[k];
                  if (((options.filter == null) || (ref1 = v.constructor, indexOf.call(options.filter, ref1) >= 0)) && (options.own !== true || {}.hasOwnProperty.call(o, k)) && (chunk = write((i++ > 0 ? ',' + nit : '') + (options.variable && level === 0 ? k : "'" + k.toString().replace(/\'/g, "\\'") + "'") + (options.variable && level === 0 ? '=' : ':')) + doit(v, level + 1))) {
                    results.push(chunk);
                  }
                }
                return results;
              })()).join('')), write("" + ni + (options.variable && level === 0 ? ';' : '}')));
            }
          }
          break;
        case '[object Array]':
          if (array_as_object) {
            i = 0;
            return concat(write(sep + ("function () {" + nit + "var a = []; var o = {" + nit)), "" + (((function() {
              var results;
              results = [];
              for (k in o) {
                if (!hasProp.call(o, k)) continue;
                v = o[k];
                if ((chunk = write((i++ > 0 ? ',' + nit : '') + k + ':') + doit(v, level + 1))) {
                  results.push(chunk);
                }
              }
              return results;
            })()).join('')), write("};" + nit + "for (var k in o) {a[k] = o[k];} return a; }()"));
          } else {
            return concat(write(sep + ("[" + nit)), "" + (((function() {
              var len, m, results;
              results = [];
              for (i = m = 0, len = o.length; m < len; i = ++m) {
                v = o[i];
                if ((chunk = doit(v, level + 1, i)) != null) {
                  results.push(chunk);
                }
              }
              return results;
            })()).join('')), write(ni + "]"));
          }
          break;
        case '[object Boolean]':
          return write(sep + o);
        case '[object Number]':
          return write(sep + o);
        case '[object Date]':
          return write(sep + ("new Date(" + (o.valueOf()) + ")"));
        case '[object Function]':
          return write(sep + o.toString());
        case '[object Math]':
          return write(sep + 'Math');
        case '[object String]':
          return write(sep + ("'" + (o.replace(/\'/g, '\\\'')) + "'"));
        case '[object Undefined]':
          return write(sep + 'void 0');
        case '[object Null]':
          return write(sep + 'null');
        case '[object Buffer]':
        case '[object SlowBuffer]':
          return write(sep + (o.length === 16 ? _.Uuid.unparse(o) : o.toString()));
      }
    };
    return doit(object);
  };

  _.parse = function(str) {
    return (new Function("return " + str))();
  };

  _.param = function(parameters) {
    var parameter, serialize;
    if (_.type(parameters) === _.Type.String) {
      return encodeURIComponent(parameters);
    }
    serialize = [];
    for (parameter in parameters) {
      if (!hasProp.call(parameters, parameter)) continue;
      serialize.push((encodeURIComponent(parameter)) + "=" + (encodeURIComponent(parameters[parameter])));
    }
    return serialize.join('&');
  };

  _.serialize = _.flow = _.async = function(options, fn) {
    var async, defer, deferred, fn_self, local, next, ref, self, undefer;
    if (fn == null) {
      fn = options;
      options = {};
    }
    self = options.self, local = options.local;
    if (self == null) {
      self = {};
    }
    if (local == null) {
      local = {};
    }
    deferred = [];
    async = false;
    defer = function(fn) {
      if (arguments.length === 2) {
        fn = arguments[1];
      }
      return deferred.push(fn);
    };
    undefer = function() {
      var undefered;
      undefered = deferred.shift();
      if (deferred.length === 0 && async === false && (options != null ? options.async : void 0) !== false) {
        return function(next) {
          return setTimeout((function() {
            return undefered != null ? undefered.call(self, next) : void 0;
          }), 0);
        };
      } else {
        return undefered;
      }
    };
    next = function() {
      var result;
      if (deferred.length) {
        result = undefer().call(self, next);
        switch (result) {
          case next:
            async = true;
        }
        return result;
      }
    };
    next.later = next;
    next["with"] = function(result) {
      if (result !== next.later) {
        return next();
      } else {
        return next.later;
      }
    };
    if (options.self == null) {
      self.next = next;
    }
    fn_self = options.self;
    if (fn_self == null) {
      fn_self = fn;
    }
    fn.call(fn_self, defer, local);
    return (ref = undefer()) != null ? ref.call(self, next) : void 0;
  };

  _.parallelize = function(self, fn) {
    var count, dfn, end, join, len, m, on_join, push, pushed, results;
    if (typeof self === 'function') {
      fn = self;
      self = fn;
    }
    pushed = [];
    on_join = null;
    join = function(fn) {
      return on_join = fn;
    };
    count = 0;
    end = function() {
      count += -1;
      if (count === 0) {
        return on_join != null ? on_join.call(self) : void 0;
      }
    };
    push = function(fn) {
      return pushed.push(function() {
        return setTimeout((function() {
          fn.call(self);
          return end();
        }), 0);
      });
    };
    fn.call(self, push, join);
    count = pushed.length;
    results = [];
    for (m = 0, len = pushed.length; m < len; m++) {
      dfn = pushed[m];
      results.push(dfn.call(self));
    }
    return results;
  };

  _.throttle = function(options, func) {
    var accumulate, args, call, ctx, last, reset, rtn, timeoutID, wait;
    if (func == null) {
      func = options;
      options = {};
    }
    wait = options.wait, reset = options.reset, accumulate = options.accumulate;
    if (wait == null) {
      wait = 1000;
    }
    if (reset == null) {
      reset = false;
    }
    if (accumulate == null) {
      accumulate = false;
    }
    ctx = void 0;
    args = void 0;
    rtn = void 0;
    timeoutID = void 0;
    last = 0;
    call = function() {
      timeoutID = void 0;
      last = (new Date).getTime();
      rtn = func.apply(ctx, args);
      ctx = void 0;
      args = void 0;
    };
    return function() {
      var delta;
      ctx = this;
      if (!accumulate) {
        args = arguments;
      } else if (args == null) {
        args = [arguments];
      } else {
        args.push(arguments);
      }
      delta = (new Date).getTime() - last;
      if (reset) {
        if (timeoutID != null) {
          clearTimeout(timeoutID);
        }
        timeoutID = setTimeout(call, wait);
      } else if (timeoutID == null) {
        if (delta >= wait) {
          call();
        } else {
          timeoutID = setTimeout(call, wait - delta);
        }
      }
      return rtn;
    };
  };

  _.extend = function(object, values, overwrite) {
    var set;
    set = function(o, val) {
      var k, v;
      for (k in val) {
        if (!hasProp.call(val, k)) continue;
        v = val[k];
        if (o == null) {
          o = {};
        }
        if (_.type(o[k]) === _.Type.Object && _.type(v) === _.Type.Object) {
          set(o[k], v);
        } else {
          if (!(overwrite === false && (o[k] != null))) {
            o[k] = v;
          }
        }
      }
      return o;
    };
    return set(object, values);
  };

  _.clone = function() {
    var clone, copy, copyIsArray, i, length, name, options, src, target;
    target = arguments[0] || {};
    length = arguments.length;
    if (length === 1) {
      i = 0;
      target = {};
    } else {
      i = 1;
      if (typeof target !== "object" && !_.type(target) === _.Type.Function) {
        target = {};
      }
    }
    while (i < length) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (copy && (_.isBasicObject(copy) || (copyIsArray = _.type(copy) === _.Type.Array))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && _.type(src) === _.Type.Array ? src : [];
            } else {
              clone = src && _.isBasicObject(src) ? src : {};
            }
            target[name] = _.clone(clone, copy);
          } else if (copy !== void 0) {
            target[name] = copy;
          }
        }
      }
      i += 1;
    }
    return target;
  };

  _.defaults = function(object, defaults) {
    return _.extend(object, defaults, false);
  };

  _.cell = function(def, options) {
    var signal;
    signal = new Signal(def, options);
    return function(def) {
      var method;
      if (def != null) {
        if (arguments.length > 1) {
          method = Array.prototype.splice.call(arguments, 0, 1);
          return signal[method].apply(signal, arguments);
        } else {
          if (def === _) {
            return signal;
          } else {
            return signal.value.call(signal, def);
          }
        }
      } else {
        return signal.value.call(signal);
      }
    };
  };

  _.observer = function(def) {
    var observer;
    observer = new Observer(def);
    return function(def) {
      var method;
      if (arguments.length > 1) {
        method = Array.prototype.splice.call(arguments, 0, 1);
        return observer[method].apply(observer, arguments);
      } else {
        return observer.observe(def);
      }
    };
  };

  _.Signal = _.Cell = Signal = _.prototype({
    adopt: {
      type: 0x0100,
      idle: 0x0001,
      initialized: 0x0002,
      object: 0x0004,
      array: 0x0008,

      /* Events on evalutate
          value   REPLACE - ALL
          set     REPLACE - ONE - at KEY
          delete  REMOVE - ONE - at KEY
          pop     REMOVE - ONE - at LAST
          push    INSERT - ONE or MANY - at END 
          reverse SORT - ALL
          shift   REMOVE - ONE - at FIRST
          sort    SORT - ALL
          splice  REMOVE - ONE or MANY - at INDEX and INSERT - ONE or MANY - at INDEX
          unshift INSERT - ONE or MANY - at FIRST
       */
      Event: {
        Type: {
          Insert: 0,
          Replace: 1,
          Remove: 2,
          Sort: 3
        },
        What: {
          All: 0,
          One: 1,
          Many: 2
        },
        Where: {
          First: 0,
          Last: 1,
          End: 2,
          Index: 3
        }
      },
      EventDef: {
        value: {
          type: 'Replace',
          what: 'All'
        },
        set: {
          type: 'Replace',
          what: 'One',
          where: 'Index'
        },
        "delete": {
          type: 'Remove',
          what: 'One',
          where: 'Index'
        },
        pop: {
          type: 'Remove',
          what: 'One',
          where: 'Last'
        },
        push: {
          type: 'Insert',
          what: 'One',
          where: 'End'
        },
        reverse: {
          type: 'Sort',
          what: 'All'
        },
        shift: {
          type: 'Remove',
          what: 'One',
          where: 'First'
        },
        sort: {
          type: 'Sort',
          what: 'All'
        },
        splice: {
          type: 'Remove',
          what: 'One',
          where: 'Index'
        },
        unshift: {
          type: 'Insert',
          what: 'One',
          where: 'First'
        }
      },
      dependencyStack: [],
      transactions: {},
      Defer: _.prototype({
        constructor: function(signal1, observerList1) {
          this.signal = signal1;
          this.observerList = observerList1;
          return this.count = 0;
        },
        value: function(fn) {
          var len, m, observer, ref, results, stack;
          stack = Signal.dependencyStack;
          Signal.dependencyStack = [this.signal];
          this.signal._value = fn();
          this.signal.flags |= Signal.idle | Signal.initialized;
          Signal.dependencyStack = stack;
          this.count += -1;
          this.signal.propagate(this.observerList, this);
          if (this.signal.observers != null) {
            ref = this.signal.observers;
            results = [];
            for (m = 0, len = ref.length; m < len; m++) {
              observer = ref[m];
              results.push(observer.notify(true));
            }
            return results;
          }
        },
        one: function() {
          return this.count += 1;
        },
        idle: function() {
          return this.count === 0;
        }
      })
    },
    constructor: function(definition, options1) {
      var fn1, helper, name, ref, ref1;
      this.definition = definition;
      this.options = options1;
      ref = this.helpers;
      fn1 = function(helper, name, self) {
        return self.helpers[name] = function() {
          return helper.apply(self, arguments);
        };
      };
      for (name in ref) {
        helper = ref[name];
        fn1(helper, name, this);
      }
      if (((ref1 = this.options) != null ? ref1.id : void 0) != null) {
        this.globalize('uuid', function() {
          return _.Uuid();
        });
      }
      this._value = null;
      this.flags = Signal.type | Signal.idle;
      this.dependencies = void 0;
      this.dependents = void 0;
      this.observers = void 0;
      this.dependentTargets = void 0;
      return this.evaluate();
    },
    globalize: function(property, builder) {
      var globalize, globalized;
      globalized = {};
      globalize = function(current) {
        var item, name, pos, ref, ref1, ref2, ref3, type, value;
        if (current[property] == null) {
          item = current.value;
          type = _.type(item);
          current[property] = builder();
        }
        switch (type) {
          case _.Type.Object:
          case _.Type.Array:
            switch (type) {
              case _.Type.Object:
                for (name in item) {
                  value = item[name];
                  if (!(name !== '_' && globalized[(ref = value._) != null ? (ref1 = ref._) != null ? ref1.uuid : void 0 : void 0] !== true)) {
                    continue;
                  }
                  globalize({
                    item: value,
                    name: name,
                    parent: item
                  });
                  if (_.isObject(value)) {
                    globalized[value._._.uuid] = true;
                  }
                }
                break;
              case _.Type.Array:
                for (name in item) {
                  value = item[name];
                  if (!(name !== '_' && globalized[(ref2 = value._) != null ? (ref3 = ref2._) != null ? ref3.uuid : void 0 : void 0] !== true)) {
                    continue;
                  }
                  if ((pos = parseInt(name)).toString() !== name) {
                    pos = null;
                  }
                  globalize({
                    item: value,
                    name: (pos != null ? void 0 : name),
                    parent: {
                      item: item
                    }
                  });
                  if (_.isObject(value)) {
                    globalized[value._._.uuid] = true;
                  }
                }
            }
        }
      };
      globalize(this);
    },
    evaluate: function(observerList, defer) {
      var deferred, dependency, dependentIndex, e, len, len1, len2, m, observer, p, q, ref, ref1, ref2, ref3, result, type;
      this._value = this.definition;
      this.error = null;
      this.flags |= Signal.idle;
      this.flags &= ~Signal.object & ~Signal.array;
      if (this.dependencies != null) {
        ref = this.dependencies;
        for (m = 0, len = ref.length; m < len; m++) {
          dependency = ref[m];
          if (!(dependency.dependents != null)) {
            continue;
          }
          dependentIndex = dependency.dependents.indexOf(this);
          dependency.dependents.splice(dependentIndex, 1);
        }
      }
      this.dependencies = void 0;
      switch (type = _.type(this.definition)) {
        case _.Type.Function:
          if (defer == null) {
            defer = new Signal.Defer(this, observerList);
          }
          Signal.dependencyStack.push(this);
          try {
            deferred = (function(signal) {
              return function(fn) {
                var prev;
                prev = defer.signal;
                defer.signal = signal;
                defer.value.call(defer, fn);
                return defer.signal = prev;
              };
            })(this);
            try {
              result = this.definition(deferred);
            } catch (error) {
              e = error;
              result = void 0;
              this.error = e;
              if (this._catch != null) {
                this._catch(e);
                this.error = null;
              }
            }
            if (result === deferred) {
              this.flags &= ~Signal.idle;
              defer.one();
              if (this.observers != null) {
                ref1 = this.observers;
                for (p = 0, len1 = ref1.length; p < len1; p++) {
                  observer = ref1[p];
                  observer.notify(false);
                }
              }
            } else {
              this._value = result;
              this.flags |= Signal.idle | Signal.initialized;
            }
          } finally {
            Signal.dependencyStack.pop();
          }
          break;
        case _.Type.Object:
        case _.Type.Array:
          this.flags |= type === _.Type.Object ? Signal.object : Signal.array;
      }
      if ((observerList != null) && (this.observers != null)) {
        ref2 = this.observers;
        for (q = 0, len2 = ref2.length; q < len2; q++) {
          observer = ref2[q];
          if ((observer != null) && (observerList.indexOf(observer)) < 0) {
            observerList.push(observer);
          }
        }
      }
      if (!((deferred != null) && result === deferred)) {
        this.propagate(observerList, defer);
      }
      return (ref3 = defer != null ? defer.idle() : void 0) != null ? ref3 : true;
    },
    set: function(key, value, trigger) {
      if (arguments.length === 1) {
        this.definition = key;
      } else if (this.flags & (Signal.object | Signal.array)) {
        this.definition[key] = value;
      }
      if (trigger !== false) {
        return this.value(this.definition);
      }
    },
    get: function() {
      return this.value();
    },
    "delete": function(key, trigger) {
      if (this.flags & (Signal.object | Signal.array)) {
        delete this.definition[key];
      }
      if (trigger !== false) {
        return this.value(this.definition);
      }
    },
    pop: function() {
      var o;
      if (!(this.flags & Signal.array)) {
        return;
      }
      o = this.definition.pop.apply(this.definition, arguments);
      this.value(this.definition);
      return o;
    },
    push: function() {
      var o;
      if (!(this.flags & Signal.array)) {
        return;
      }
      o = this.definition.push.apply(this.definition, arguments);
      this.value(this.definition);
      return o;
    },
    reverse: function() {
      var o;
      if (!(this.flags & Signal.array)) {
        return;
      }
      o = this.definition.reverse.apply(this.definition, arguments);
      this.value(this.definition);
      return o;
    },
    shift: function() {
      var o;
      if (!(this.flags & Signal.array)) {
        return;
      }
      o = this.definition.shift.apply(this.definition, arguments);
      this.value(this.definition);
      return o;
    },
    sort: function() {
      var o;
      if (!(this.flags & Signal.array)) {
        return;
      }
      o = this.definition.sort.apply(this.definition, arguments);
      this.value(this.definition);
      return o;
    },
    splice: function() {
      var o;
      if (!(this.flags & Signal.array)) {
        return;
      }
      o = this.definition.splice.apply(this.definition, arguments);
      this.value(this.definition);
      return o;
    },
    unshift: function() {
      var o;
      if (!(this.flags & Signal.array)) {
        return;
      }
      o = this.definition.unshift.apply(this.definition, arguments);
      this.value(this.definition);
      return o;
    },
    "catch": function(report) {
      this._catch = report;
      if (this.error != null) {
        this._catch(this.error);
        return this.error = null;
      }
    },
    idle: function() {
      return this.flags & Signal.idle;
    },
    propagate: function(observerList, defer) {
      var dependent, len, m, ref, results;
      if (this.dependents == null) {
        return;
      }
      this.dependentTargets = this.dependents.slice(0);
      ref = this.dependents.slice(0);
      results = [];
      for (m = 0, len = ref.length; m < len; m++) {
        dependent = ref[m];
        if ((dependent != null) && this.dependentTargets.indexOf(dependent) >= 0) {
          results.push(dependent.evaluate(observerList, defer));
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    value: function(newDefinition) {
      var dependent, len, m, observer, observerList, ref, targetDependentIndex;
      if (newDefinition !== void 0) {
        this.definition = newDefinition;
        observerList = [];
        if (this.evaluate(observerList)) {
          ref = observerList.slice(0);
          for (m = 0, len = ref.length; m < len; m++) {
            observer = ref[m];
            observer.trigger();
          }
        }
        return this._value;
      } else {
        dependent = Signal.dependencyStack[Signal.dependencyStack.length - 1];
        if ((dependent != null) && dependent.flags & Signal.type) {
          if (this.dependents == null) {
            this.dependents = [];
          }
          if (this.dependents.indexOf(dependent) < 0) {
            this.dependents.push(dependent);
          }
          if (dependent.dependencies == null) {
            dependent.dependencies = [];
          }
          if (dependent.dependencies.indexOf(this) < 0) {
            dependent.dependencies.push(this);
          }
          if (this.dependentTargets == null) {
            this.dependentTargets = [];
          }
          targetDependentIndex = this.dependentTargets.indexOf(dependent);
          if (targetDependentIndex >= 0) {
            this.dependentTargets[targetDependentIndex] = null;
          }
        } else if ((dependent != null) && dependent.flags & Observer.type) {
          if (this.observers == null) {
            this.observers = [];
          }
          if (this.observers.indexOf(dependent) < 0) {
            this.observers.push(dependent);
          }
          if (dependent.observees.indexOf(this) < 0) {
            dependent.observees.push(this);
          }
        }
        return this._value;
      }
    }
  });

  _.Observer = Observer = _.prototype({
    adopt: {
      type: 0x0200
    },
    constructor: function(report) {
      this.observees = [];
      this.flags = Observer.type;
      return this.observe(report);
    },
    observe: function(report) {
      var len, len1, m, observee, observerIndex, p, ref, ref1;
      this.report = report;
      this._ready = true;
      ref = this.observees;
      for (m = 0, len = ref.length; m < len; m++) {
        observee = ref[m];
        if (!(observee.observers != null)) {
          continue;
        }
        observerIndex = observee.observers.indexOf(this);
        observee.observers.splice(dependentIndex, 1);
      }
      this.observees = [];
      Signal.dependencyStack.push(this);
      try {
        if (this.report != null) {
          this.report();
        }
      } finally {
        Signal.dependencyStack.pop();
      }
      this._ready = true;
      ref1 = this.observees;
      for (p = 0, len1 = ref1.length; p < len1; p++) {
        observee = ref1[p];
        if (!observee.idle()) {
          this._ready = false;
          break;
        }
      }
      return null;
    },
    notify: function(status) {
      var len, m, observee, ref;
      if (status === true) {
        this._ready = true;
        ref = this.observees;
        for (m = 0, len = ref.length; m < len; m++) {
          observee = ref[m];
          if (!observee.idle()) {
            this._ready = false;
            break;
          }
        }
        if (this._ready) {
          return this.trigger();
        }
      } else {
        return this._ready = false;
      }
    },
    trigger: function() {
      Signal.dependencyStack.push(this);
      try {
        if (this.report != null) {
          return this.report();
        }
      } finally {
        Signal.dependencyStack.pop();
      }
    },
    ready: function() {
      return this._ready;
    }
  });

  _.Publisher = Publisher = _.prototype({
    constructor: function() {
      this.subscribers = [];
      return this.unreported = [];
    },
    notify: function(value) {
      var len, m, ref, report, results;
      if (this.subscribers.length > 0) {
        ref = this.subscribers;
        results = [];
        for (m = 0, len = ref.length; m < len; m++) {
          report = ref[m];
          results.push(report(value));
        }
        return results;
      } else {
        return this.unreported.push(value);
      }
    },
    subscribe: function(reporter) {
      var notify, self;
      this.subscribers.push(reporter);
      if (this.unreported.length > 0) {
        self = this;
        notify = function() {
          var len, m, ref, value;
          ref = self.unreported;
          for (m = 0, len = ref.length; m < len; m++) {
            value = ref[m];
            reporter(value);
          }
          return self.unreported.length = 0;
        };
        return setTimeout(notify, 0);
      }
    }
  });

  _.slugify = function(text) {
    var specialChars;
    specialChars = {
      'à': 'a',
      'ä': 'a',
      'á': 'a',
      'â': 'a',
      'æ': 'a',
      'å': 'a',
      'ë': 'e',
      'è': 'e',
      'é': 'e',
      'ê': 'e',
      'î': 'i',
      'ï': 'i',
      'ì': 'i',
      'í': 'i',
      'ò': 'o',
      'ó': 'o',
      'ö': 'o',
      'ô': 'o',
      'ø': 'o',
      'ù': 'o',
      'ú': 'u',
      'ü': 'u',
      'û': 'u',
      'ñ': 'n',
      'ç': 'c',
      'ß': 's',
      'ÿ': 'y',
      'œ': 'o',
      'ŕ': 'r',
      'ś': 's',
      'ń': 'n',
      'ṕ': 'p',
      'ẃ': 'w',
      'ǵ': 'g',
      'ǹ': 'n',
      'ḿ': 'm',
      'ǘ': 'u',
      'ẍ': 'x',
      'ź': 'z',
      'ḧ': 'h',
      '·': '-',
      '/': '-',
      '_': '-',
      ',': '-',
      ':': '-',
      ';': '-'
    };
    return text.toString().toLowerCase().replace(/\s+/g, '-').replace(/./g, function(target, index, str) {
      return specialChars[target] || target;
    }).replace(/&/g, '-and-').replace(/[^\w\-]+/g, '').replace(/\-\-+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
  };

  _.Cuid = (function() {
    var api, base, blockSize, c, discreteValues, pad, randomBlock, safeCounter;
    c = 0;
    blockSize = 4;
    base = 36;
    discreteValues = Math.pow(base, blockSize);
    pad = function(num, size) {
      var s;
      s = '000000000' + num;
      return s.substr(s.length - size);
    };
    randomBlock = function() {
      return pad((Math.random() * discreteValues << 0).toString(base), blockSize);
    };
    safeCounter = function() {
      c = c < discreteValues ? c : 0;
      c++;
      return c - 1;
    };
    api = function() {
      var counter, fingerprint, letter, random, timestamp;
      letter = 'c';
      timestamp = (new Date).getTime().toString(base);
      counter = void 0;
      fingerprint = api.fingerprint();
      random = randomBlock() + randomBlock();
      counter = pad(safeCounter().toString(base), blockSize);
      return letter + timestamp + counter + fingerprint + random;
    };
    api.slug = function() {
      var counter, date, print, random;
      date = (new Date).getTime().toString(36);
      counter = void 0;
      print = api.fingerprint().slice(0, 1) + api.fingerprint().slice(-1);
      random = randomBlock().slice(-2);
      counter = safeCounter().toString(36).slice(-4);
      return date.slice(-2) + counter + print + random;
    };
    api.globalCount = typeof window === "undefined" || window === null ? void 0 : function() {
      var cache;
      cache = (function() {
        var count, i;
        i = void 0;
        count = 0;
        for (i in window) {
          count++;
        }
        return count;
      })();
      api.globalCount = function() {
        return cache;
      };
      return cache;
    };
    api.fingerprint = typeof window !== "undefined" && window !== null ? function() {
      return pad((navigator.mimeTypes.length + navigator.userAgent.length).toString(36) + api.globalCount().toString(36), 4);
    } : function() {
      var hostId, hostname, length, os, padding, pid;
      os = require('os');
      padding = 2;
      pid = pad(process.pid.toString(36), padding);
      hostname = os.hostname();
      length = hostname.length;
      hostId = pad(hostname.split('').reduce((function(prev, char) {
        return +prev + char.charCodeAt(0);
      }), +length + 36).toString(36), padding);
      return pid + hostId;
    };
    return api;
  })();

  _.Uuid = (function(_module) {
    var BufferClass, _byteToHex, _clockseq, _hexToByte, _lastMSecs, _lastNSecs, _nodeId, _previousRoot, _rb, _rnds, _rnds8, _rng, _seedBytes, crypto, define, i, module, parse, require, unparse, uuid, v1, v4, whatwgRNG;
    require = _module.require, crypto = _module.crypto, define = _module.define, module = _module.module;
    _rng = void 0;
    if (typeof require === "function") {
      try {
        _rb = require("crypto").randomBytes;
        _rng = _rb && function() {
          return _rb(16);
        };
      } catch (error) {}
    }
    if (!_rng && crypto && crypto.getRandomValues) {
      _rnds8 = new Uint8Array(16);
      _rng = whatwgRNG = function() {
        crypto.getRandomValues(_rnds8);
        return _rnds8;
      };
    }
    if (!_rng) {
      _rnds = new Array(16);
      _rng = function() {
        var i, r;
        i = 0;
        r = void 0;
        while (i < 16) {
          if ((i & 0x03) === 0) {
            r = Math.random() * 0x100000000;
          }
          _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
          i++;
        }
        return _rnds;
      };
    }
    BufferClass = (typeof Buffer === "function" ? Buffer : Array);
    _byteToHex = [];
    _hexToByte = {};
    i = 0;
    while (i < 256) {
      _byteToHex[i] = (i + 0x100).toString(16).substr(1);
      _hexToByte[_byteToHex[i]] = i;
      i++;
    }
    parse = function(s, buf, offset) {
      var ii;
      i = (buf && offset) || 0;
      ii = 0;
      buf = buf || [];
      s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
        if (ii < 16) {
          return buf[i + ii++] = _hexToByte[oct];
        }
      });
      while (ii < 16) {
        buf[i + ii++] = 0;
      }
      return buf;
    };
    unparse = function(buf, offset) {
      var bth;
      i = offset || 0;
      bth = _byteToHex;
      return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + "-" + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];
    };
    _seedBytes = _rng();
    _nodeId = [_seedBytes[0] | 0x01, _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]];
    _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;
    _lastMSecs = 0;
    _lastNSecs = 0;
    v1 = function(options, buf, offset) {
      var b, clockseq, dt, msecs, n, node, nsecs, tl, tmh;
      i = buf && offset || 0;
      b = buf || [];
      options = options || {};
      clockseq = (options.clockseq != null ? options.clockseq : _clockseq);
      msecs = (options.msecs != null ? options.msecs : new Date().getTime());
      nsecs = (options.nsecs != null ? options.nsecs : _lastNSecs + 1);
      dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs) / 10000;
      if (dt < 0 && (options.clockseq == null)) {
        clockseq = clockseq + 1 & 0x3fff;
      }
      if ((dt < 0 || msecs > _lastMSecs) && (options.nsecs == null)) {
        nsecs = 0;
      }
      if (nsecs >= 10000) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 12219292800000;
      tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
      b[i++] = tl >>> 24 & 0xff;
      b[i++] = tl >>> 16 & 0xff;
      b[i++] = tl >>> 8 & 0xff;
      b[i++] = tl & 0xff;
      tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
      b[i++] = tmh >>> 8 & 0xff;
      b[i++] = tmh & 0xff;
      b[i++] = tmh >>> 24 & 0xf | 0x10;
      b[i++] = tmh >>> 16 & 0xff;
      b[i++] = clockseq >>> 8 | 0x80;
      b[i++] = clockseq & 0xff;
      node = options.node || _nodeId;
      n = 0;
      while (n < 6) {
        b[i + n] = node[n];
        n++;
      }
      if (buf) {
        return buf;
      } else {
        return unparse(b);
      }
    };
    v4 = function(options, buf, offset) {
      var ii, rnds;
      i = buf && offset || 0;
      if (typeof options === "string") {
        buf = (options === "binary" ? new BufferClass(16) : null);
        options = null;
      }
      options = options || {};
      rnds = options.random || (options.rng || _rng)();
      rnds[6] = (rnds[6] & 0x0f) | 0x40;
      rnds[8] = (rnds[8] & 0x3f) | 0x80;
      if (buf) {
        ii = 0;
        while (ii < 16) {
          buf[i + ii] = rnds[ii];
          ii++;
        }
      }
      return buf || unparse(rnds);
    };
    uuid = v4;
    uuid.v1 = v1;
    uuid.v4 = v4;
    uuid.parse = parse;
    uuid.unparse = unparse;
    uuid.BufferClass = BufferClass;
    if (typeof define === "function" && define.amd) {
      define(function() {
        return uuid;
      });
    } else if (typeof module !== "undefined" && module.exports) {
      module.exports = uuid;
    } else {
      _previousRoot = _module.Uuid;
      uuid.noConflict = function() {
        _module.Uuid = _previousRoot;
        return uuid;
      };
      _module.Uuid = uuid;
    }
    uuid.isUuid = function(value) {
      var parsed, unparsed;
      if ((value != null) && Object.prototype.toString.apply(value === '[object String]' && value.length === 36)) {
        parsed = parse(value);
        unparsed = unparse(parsed);
        return value === unparsed;
      } else if (typeof Buffer === 'function' && Buffer.isBuffer(value)) {
        return value.length === 16;
      } else {
        return false;
      }
    };
    uuid["interface"] = function() {
      return uuid();
    };
    return uuid;
  })(_module);


  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */


  /*  SHA-256 implementation in JavaScript                (c) Chris Veness 2002-2014 / MIT Licence */


  /*  - see http://csrc.nist.gov/groups/ST/toolkit/secure_hashing.html */


  /*        http://csrc.nist.gov/groups/ST/toolkit/examples.html */


  /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

  _.Sha256 = (function() {

    /* global define, escape, unescape */
    var Sha256;
    Sha256 = void 0;
    Sha256 = {};

    /**
     * Generates SHA-256 hash of string.
     *
     * @param   {string} msg - String to be hashed
     * @returns {string} Hash of msg as hex character string
     */
    Sha256.hash = function(msg) {
      var H, K, M, N, T1, T2, W, a, b, c, d, e, f, g, h, i, j, l, t;
      t = void 0;
      t = void 0;
      i = void 0;
      H = void 0;
      K = void 0;
      M = void 0;
      N = void 0;
      T1 = void 0;
      T2 = void 0;
      W = void 0;
      a = void 0;
      b = void 0;
      c = void 0;
      d = void 0;
      e = void 0;
      f = void 0;
      g = void 0;
      h = void 0;
      i = void 0;
      j = void 0;
      l = void 0;
      t = void 0;
      msg = msg.utf8Encode();
      K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
      H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
      msg += String.fromCharCode(0x80);
      l = msg.length / 4 + 2;
      N = Math.ceil(l / 16);
      M = new Array(N);
      i = 0;
      while (i < N) {
        M[i] = new Array(16);
        j = 0;
        while (j < 16) {
          M[i][j] = msg.charCodeAt(i * 64 + j * 4) << 24 | msg.charCodeAt(i * 64 + j * 4 + 1) << 16 | msg.charCodeAt(i * 64 + j * 4 + 2) << 8 | msg.charCodeAt(i * 64 + j * 4 + 3);
          j++;
        }
        i++;
      }
      M[N - 1][14] = (msg.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (msg.length - 1) * 8 & 0xffffffff;
      W = new Array(64);
      a = void 0;
      b = void 0;
      c = void 0;
      d = void 0;
      e = void 0;
      f = void 0;
      g = void 0;
      h = void 0;
      i = 0;
      while (i < N) {
        t = 0;
        while (t < 16) {
          W[t] = M[i][t];
          t++;
        }
        t = 16;
        while (t < 64) {
          W[t] = Sha256.sigma1(W[t - 2]) + W[t - 7] + Sha256.sigma0(W[t - 15]) + W[t - 16] & 0xffffffff;
          t++;
        }
        a = H[0];
        b = H[1];
        c = H[2];
        d = H[3];
        e = H[4];
        f = H[5];
        g = H[6];
        h = H[7];
        t = 0;
        while (t < 64) {
          T1 = h + Sha256.Sigma1(e) + Sha256.Ch(e, f, g) + K[t] + W[t];
          T2 = Sha256.Sigma0(a) + Sha256.Maj(a, b, c);
          h = g;
          g = f;
          f = e;
          e = d + T1 & 0xffffffff;
          d = c;
          c = b;
          b = a;
          a = T1 + T2 & 0xffffffff;
          t++;
        }
        H[0] = H[0] + a & 0xffffffff;
        H[1] = H[1] + b & 0xffffffff;
        H[2] = H[2] + c & 0xffffffff;
        H[3] = H[3] + d & 0xffffffff;
        H[4] = H[4] + e & 0xffffffff;
        H[5] = H[5] + f & 0xffffffff;
        H[6] = H[6] + g & 0xffffffff;
        H[7] = H[7] + h & 0xffffffff;
        i++;
      }
      return Sha256.toHexStr(H[0]) + Sha256.toHexStr(H[1]) + Sha256.toHexStr(H[2]) + Sha256.toHexStr(H[3]) + Sha256.toHexStr(H[4]) + Sha256.toHexStr(H[5]) + Sha256.toHexStr(H[6]) + Sha256.toHexStr(H[7]);
    };

    /**
     * Rotates right (circular right shift) value x by n positions [§3.2.4].
     * @private
     */
    Sha256.ROTR = function(n, x) {
      return x >>> n | x << 32 - n;
    };

    /**
     * Logical functions [§4.1.2].
     * @private
     */
    Sha256.Sigma0 = function(x) {
      return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x);
    };
    Sha256.Sigma1 = function(x) {
      return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x);
    };
    Sha256.sigma0 = function(x) {
      return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ x >>> 3;
    };
    Sha256.sigma1 = function(x) {
      return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ x >>> 10;
    };
    Sha256.Ch = function(x, y, z) {
      return x & y ^ ~x & z;
    };
    Sha256.Maj = function(x, y, z) {
      return x & y ^ x & z ^ y & z;
    };

    /**
     * Hexadecimal representation of a number.
     * @private
     */
    Sha256.toHexStr = function(n) {
      var i, s, v;
      i = void 0;
      s = void 0;
      v = void 0;
      s = '';
      v = void 0;
      i = 7;
      while (i >= 0) {
        v = n >>> i * 4 & 0xf;
        s += v.toString(16);
        i--;
      }
      return s;
    };

    /* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

    /** Extend String object with method to encode multi-byte string to utf8
     *  - monsur.hossa.in/2012/07/20/utf-8-in-javascript.html
     */
    if (typeof String.prototype.utf8Encode == 'undefined') {
      String.prototype.utf8Encode = function() {
        return unescape(encodeURIComponent(this));
      };
    }

    /** Extend String object with method to decode utf8 string to multi-byte */
    if (typeof String.prototype.utf8Decode == 'undefined') {
      String.prototype.utf8Decode = function() {
        var _error, e;
        e = void 0;
        try {
          return decodeURIComponent(escape(this));
        } catch (error) {
          _error = error;
          e = _error;
          return this;
        }
      };
    }
    return Sha256;
  })();

  (function(_) {
    var actions;
    _.go = function(where, callback) {
      if (_.type(where) === _.Type.String) {
        return typeof window !== "undefined" && window !== null ? window.location = where : void 0;
      } else {
        return typeof where.submit === "function" ? where.submit(callback) : void 0;
      }
    };
    actions = [];
    actions.Type = {
      Create: 1,
      Attach: 2,
      Update: 3,
      Detach: 4,
      Delete: 5
    };
    actions["do"] = function(arg) {
      var action, contained, object, parent, position, property, type, uuid, value;
      action = arg.action, object = arg.object, type = arg.type, uuid = arg.uuid, property = arg.property, value = arg.value, parent = arg.parent, contained = arg.contained;
      if (type == null) {
        type = _.type(object);
      }
      switch (action) {
        case actions.Type.Create:
          return actions.push({
            what: action,
            where: {
              u: uuid != null ? uuid : object.uuid,
              n: property,
              c: contained,
              a: parent,
              t: type
            }
          });
        case actions.Type.Attach:
          if (type === _.Type.Array) {
            position = property = object.length;
          }
          return actions.push({
            what: action,
            where: {
              u: _["do"].uuid({
                parent: object,
                property: property,
                create: true
              }),
              n: property,
              d: value,
              a: object._._.uuid,
              p: position
            }
          });
        case actions.Type.Update:
          return actions.push({
            what: action,
            where: {
              u: _["do"].uuid({
                parent: object,
                property: property
              }),
              d: value
            }
          });
        case actions.Type.Detach:
          return actions.push({
            what: action,
            where: {
              u: _["do"].uuid({
                parent: object,
                property: property
              })
            }
          });
        case actions.Type.Delete:
          return actions.push({
            what: action,
            where: {
              u: uuid != null ? uuid : object.uuid
            }
          });
      }
    };
    _["do"] = function(object, uuid) {
      return uuid != null ? uuid : uuid = object.uuid;
    };
    _["do"].flush = function() {
      var actions_;
      if (actions.length === 0) {
        return null;
      }
      actions_ = actions.slice(0);
      actions.length = 0;
      return actions_;
    };
    _["do"].internal = function(object, name, value) {
      var base1, base2;
      if (_.isObject(object)) {
        if (object._ == null) {
          object._ = _.type(object) === _.Type.Array ? [] : {};
        }
        if ((base1 = object._)._ == null) {
          base1._ = {};
        }
        if (name != null) {
          if ((base2 = object._._)[name] == null) {
            base2[name] = value;
          }
        }
      }
      return object;
    };
    _["do"].identify = function(object, options) {
      var filter, identified, identify;
      if (options == null) {
        options = {};
      }
      filter = options != null ? options.filter : void 0;
      identified = {};
      identify = function(current) {
        var base1, base2, base3, index, item, name, parent, pos, position, ref, ref1, ref2, ref3, ref4, ref5, ref6, type, uuid, value;
        item = current.item, name = current.name, parent = current.parent, position = current.position;
        ref = {
          uuid: _["do"].uuid({
            object: item,
            parent: parent != null ? parent.object : void 0,
            property: name
          }),
          type: _.type(item)
        }, uuid = ref.uuid, type = ref.type;
        if (name === '_') {
          return;
        }
        _["do"].internal(item, 'uuid', uuid != null ? uuid : _.Uuid());
        if ((parent != null ? parent.object : void 0) != null) {
          if ((base1 = parent.object)._ == null) {
            base1._ = _.type(parent.object) === _.Type.Array ? [] : {};
          }
          index = name != null ? name : position;
          if ((base2 = parent.object._)[index] == null) {
            base2[index] = type === _.Type.Array ? [] : {};
          }
          if ((base3 = parent.object._[index]).uuid == null) {
            base3.uuid = uuid != null ? uuid : uuid = _.Uuid();
          }
        }
        switch (type) {
          case _.Type.Object:
          case _.Type.Array:
            switch (type) {
              case _.Type.Object:
                for (name in item) {
                  value = item[name];
                  if (!(name !== '_' && ((filter == null) || (ref1 = value != null ? value.constructor : void 0, indexOf.call(filter, ref1) >= 0)) && identified[(ref2 = value._) != null ? (ref3 = ref2._) != null ? ref3.uuid : void 0 : void 0] !== true)) {
                    continue;
                  }
                  identify({
                    item: value,
                    name: name,
                    parent: {
                      object: item
                    }
                  });
                  if (_.isObject(value)) {
                    identified[value._._.uuid] = true;
                  }
                }
                break;
              case _.Type.Array:
                for (name in item) {
                  value = item[name];
                  if (!(name !== '_' && ((filter == null) || (ref4 = value != null ? value.constructor : void 0, indexOf.call(filter, ref4) >= 0)) && identified[(ref5 = value._) != null ? (ref6 = ref5._) != null ? ref6.uuid : void 0 : void 0] !== true)) {
                    continue;
                  }
                  if ((pos = parseInt(name)).toString() !== name) {
                    pos = null;
                  }
                  identify({
                    item: value,
                    name: (pos != null ? void 0 : name),
                    parent: {
                      object: item
                    },
                    position: pos
                  });
                  if (_.isObject(value)) {
                    identified[value._._.uuid] = true;
                  }
                }
            }
        }
      };
      identify({
        item: object,
        parent: (options.parent != null ? {
          object: options.parent
        } : null),
        name: options.name
      });
      return object;
    };
    _["do"].uuid = function(arg) {
      var base1, create, object, parent, property, ref, ref1, ref2, uuid;
      object = arg.object, parent = arg.parent, property = arg.property, create = arg.create;
      if ((object == null) && (parent != null) && (property != null)) {
        object = parent[property];
      }
      if (object == null) {
        return void 0;
      }
      uuid = (ref = object.uuid) != null ? ref : parent != null ? (ref1 = parent._) != null ? (ref2 = ref1[property]) != null ? ref2.uuid : void 0 : void 0 : void 0;
      if ((uuid == null) && create) {
        uuid = _.Uuid();
        if ((parent != null) && (property != null)) {
          parent._[property].uuid = uuid;
        }
        if (object._ == null) {
          object._ = _.type(object) === _.Type.Array ? [] : {};
        }
        if ((base1 = object._)._ == null) {
          base1._ = {
            uuid: uuid
          };
        }
      }
      return uuid;
    };
    _["do"].set = function(object, property, value) {
      var action, index, k, set, v;
      if (!_.isObject(object)) {
        return;
      }
      if (object._ == null) {
        _["do"].identify(object);
      }
      set = function(o, k, v) {
        if (_.isObject(v) && (v._ == null)) {
          _["do"].identify(v);
        }
        return o[k] = v;
      };
      action = actions.Type.Update;
      switch (_.type(property)) {
        case _.Type.Number:
        case _.Type.String:
          if (object[property] == null) {
            action = actions.Type.Attach;
          }
          actions["do"]({
            action: action,
            object: object,
            property: property,
            value: value
          });
          set(object, property, value);
          break;
        case _.Type.Object:
          if (_.type(object) === _.Type.Array) {
            for (k in property) {
              v = property[k];
              if ((index = parseInt(k)) !== Number.NaN) {
                if (object[index] == null) {
                  action = actions.Type.Attach;
                }
                actions["do"]({
                  action: action,
                  object: object,
                  property: index,
                  value: v
                });
                set(object, index, v);
              } else {
                if (object[k] == null) {
                  action = actions.Type.Attach;
                }
                actions["do"]({
                  action: action,
                  object: object,
                  property: k,
                  value: v
                });
                set(object, k, v);
              }
            }
          } else {
            for (k in property) {
              v = property[k];
              if (object[k] == null) {
                action = actions.Type.Attach;
              }
              actions["do"]({
                action: action,
                object: object,
                property: k,
                value: v
              });
              set(object, k, v);
            }
          }
      }
      return object;
    };
    _["do"].pop = function(array) {
      return array.pop();
    };
    _["do"].push = function() {
      var array;
      array = Array.prototype.shift.call(arguments);
      return Array.prototype.push.apply(array, arguments);
    };
    _["do"].reverse = function() {
      var array;
      array = Array.prototype.shift.call(arguments);
      return Array.prototype.reverse.apply(array, arguments);
    };
    _["do"].shift = function() {
      var array;
      array = Array.prototype.shift.call(arguments);
      return Array.prototype.shift.apply(array, arguments);
    };
    _["do"].sort = function() {
      var array;
      array = Array.prototype.shift.call(arguments);
      return Array.prototype.sort.apply(array, arguments);
    };
    _["do"].splice = function() {
      var array;
      array = Array.prototype.shift.call(arguments);
      return Array.prototype.splice.apply(array, arguments);
    };
    return _["do"].unshift = function() {
      var array;
      array = Array.prototype.shift.call(arguments);
      return Array.prototype.unshift.apply(array, arguments);
    };
  })(_);

}).call(this);
